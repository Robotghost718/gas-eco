<script>
  /* global Config Form DateUtils HTML toast Utility */
  /* exported FormPage */
  const FormPage = (function () {
    const usernameDisplay = document.querySelector("span.usernameDisplay");
    const Changes = (function () {
      let saved = true;
      let stack = [];
      return {
        add(change) {
          let newChange = {
            name: change.target.name,
            value: change.target.value,
            timestamp: Date.now(),
          };
          stack.push(newChange);
          saved = false;
        },
        clear() {
          stack = [];
          saved = true;
        },
        getStack() {
          return stack.slice();
        },
        isSaved() {
          return saved;
        },
        makeNote() {
          return {
            timestamp: Date.now(),
            author: usernameDisplay.textContent,
            body: JSON.stringify(this.stack),
          };
        },
      };
    })();
    const updateButtonText = {
      enabled: {
        CLOSE: "Update and Close",
        CREATE: "Submit",
        UPDATE: "Update",
      },
      disabled: "all changes saved",
    };
    const elements = {
      advanceBookingButton: document.querySelector(
        'button[value="advanceBooking"]'
      ),
      changeLogButton: document.querySelector('button[value="changeLog"]'),
      container: document.querySelector("div.formContainer"),
      copyButton: document.querySelector('button[value="copyItems"]'),
      currentFormstackDisplay: document.querySelector(
        "span.currentFormstackDisplay"
      ),
      deleteFormButton: document.querySelector('button[value="deleteForm"]'),
      duplicateButton: document.querySelector(
        'button[value="displayDuplicatedForm"]'
      ),
      focusGuardTop: document.querySelector(".focusGuardTop"),
      focusGuardBottom: document.querySelector(".focusGuardBottom"),
      form: document.querySelector("form.model"),
      itemList: document.querySelector("tbody.itemList"),
      locationSelect: document.querySelector(
        'form.model select[name="location"]'
      ),
      locationOtherOption: document.querySelector(
        'form.model option[value="Other"]'
      ),
      newNoteButton: document.querySelector('button[value="newNote"]'),
      manualButton: document.querySelector('button[value="newManual"]'),
      nextFormButton: document.querySelector('button[value="nextForm"]'),
      noteSection: document.querySelector("section.globalnotes"),
      omnibox: document.querySelector("input.omnibox"),
      omniboxButton: document.querySelector('button[value="parseOmnibox"]'),
      previousFormButton: document.querySelector(
        'button[value="previousForm"]'
      ),
      studentList: document.querySelector("tbody.studentList"),
      tableStaticFields: document.querySelector("table.staticFields"),
      undoButton: document.querySelector('button[value="undo"]'),
      updateButtonHint: document.querySelector("span.updateButtonHint"),
      updateFormButton: document.querySelector('button[value="updateForm"]'),
    };

    const noop = () => undefined;
    const handlers = {
      onDelete: noop,
      onDisplayForm: noop,
      onItemMetaClick: noop,
      onItemQuantityChange: noop,
      onManualEntry: noop,
      onModalQuantityChange: noop,
      onParseInput: noop,
      onStudentMetaClick: noop,
      onSubmit: noop,
      onUnload: noop,
    };
    const connections = {}; // getCurrentForm, getStack

    let autosaveID = null;
    let savedForm = new Form({});
    let currentStack = null;
    let locked = false;
    let timeoutId = null;
    let touched = new Set();

    elements.advanceBookingButton.addEventListener("click", () => {
      HTML.modal({
        children: [
          HTML.heading1("Save for later?"),
          HTML.paragraph(
            "All sign-in and check-out info will be removed. " +
              "Add all people and items before saving. " +
              "You can only do this once."
          ),
        ],
        closeText: "Cancel",
        okText: "Save as advance booking",
        onOk: makeAdvanceBooking,
      });
    });
    elements.changeLogButton.addEventListener("click", () => {
      const changes = [
        ...getCurrentStack()
          .getCurrentForm()
          .notes.reduce((areChanges, note) => {
            const change = Utility.tryJsonParse(note.body);
            if (!Array.isArray(change)) return areChanges;
            change.forEach((entry) => (entry.author = note.author));
            return [...areChanges, ...change];
          }, []),
        ...Changes.getStack(),
      ];
      HTML.modal({
        children: [
          HTML.table(
            HTML.row(...["Time", "User", "Field", "Value"].map(HTML.cell))
          ),
          ...changes.map(({ timestamp, author, name, value }) =>
            HTML.row(
              HTML.cell(DateUtils.getFormattedDate(new Date(timestamp))),
              HTML.cell(author),
              HTML.cell(Utility.uncamelCase(name)),
              HTML.cell(value)
            )
          ),
        ],
      });
    });
    elements.copyButton.addEventListener("click", () =>
      Utility.copyToClipboard(
        JSON.stringify(getCurrentStack().getCurrentForm().items.getStripped())
      )
    );
    elements.deleteFormButton.addEventListener("click", () => {
      if (FormPage.getSavedForm().isBlank()) {
        return handlers.onDelete();
      }
      HTML.modal({
        child: HTML.paragraph(
          "This will close out the form and mark it deleted. Are you sure?"
        ),
        closeText: "Cancel",
        onOk: () => {
          FormPage.lock();
          FormPage.setDeleteFormButtonToSpinner();
          const form = connections.getCurrentForm();
          Changes.add({
            target: {
              name: "delete",
              value: "form deleted",
            },
          });
          form.notes.push(Changes.makeNote());
          handlers.onDelete(form.stringify());
        },
      });
    });
    elements.duplicateButton.addEventListener("click", () => {
      const newForm = new Form(FormPage.getSavedForm(), true);
      const stack = connections.getStack();
      FormPage.setCurrentStack(stack);
      stack.push(newForm);
      // app.changes.saved = false; //! TODO - do we need this?
      FormPage.displayForm(newForm);
    });
    elements.manualButton.addEventListener("click", () =>
      handlers.onManualEntry()
    );
    elements.nextFormButton.addEventListener("click", getNext);
    elements.previousFormButton.addEventListener("click", getPrevious);
    elements.itemList.addEventListener("click", handleClickItem);
    elements.tableStaticFields.addEventListener(
      "click",
      handleClickStaticTable
    );
    elements.studentList.addEventListener("click", handleClickStudent);
    elements.container.addEventListener("change", handleChange);
    elements.container.addEventListener("submit", (event) =>
      event.preventDefault()
    );
    // focus guards create a tab/shift-tab closed loop through the form inputs
    elements.focusGuardTop.addEventListener("focus", () =>
      elements.locationSelect.focus()
    );
    elements.focusGuardBottom.addEventListener("focus", () =>
      elements.omnibox.focus()
    );
    elements.newNoteButton.addEventListener("click", () => {
      const input = HTML.createElement("textarea");
      HTML.modal({
        children: [
          HTML.heading1("New note"),
          HTML.paragraph("Enter a note"),
          input,
        ],
        okText: "Save note",
        onOk: () => saveNote(input.value),
      });
      input.focus();
    });
    elements.omniboxButton.addEventListener("click", handlers.onParseInput);
    elements.undoButton.addEventListener("click", () =>
      HTML.modal({
        children: [
          HTML.heading1("Undo all changes"),
          HTML.paragraph(
            "Do you want to undo all changes since the last save?"
          ),
        ],
        okText: "Revert to saved form",
        onOk: () => {
          // if (!window.isNaN(app.pages.form.autosaveID)) {
          //   window.clearTimeout(app.pages.form.autosaveID);
          //   app.pages.form.autosaveID = NaN;
          // }
          displayForm(connections.getCurrentForm());
        },
      })
    );
    elements.container.addEventListener("keydown", (event) => {
      if ((event.metaKey || event.ctrlKey) && event.key === "Enter") {
        submit();
      }
    });
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload}
     */
    window.addEventListener("beforeunload", function (event) {
      if (!Changes.isSaved()) {
        const confirmationMessage = "Are you sure?";
        event.returnValue = confirmationMessage; // Gecko, Trident, Chrome 34+
        return confirmationMessage; // Gecko, WebKit, Chrome <34
      } else {
        handlers.onUnload();
      }
    });

    const exported = {
      disable,
      displayForm,
      enable,
      getCurrentStack,
      getSavedForm,
      handleChange,
      hide,
      isLocked,
      isSaved,
      isShowing,
      lock,
      lockButtons,
      loseData,
      loseDataWarning,
      saveNote,
      setConnections,
      setCurrentStack,
      setDeleteFormButtonToSpinner,
      setHandlers,
      setSavedForm,
      setUpdateFormButtonToSpinner,
      show,
      updateItems,
      updateStudents,
    };

    return exported;

    // function checkForms() {
    //   app.run
    //     .withUserObject({ timeoutId: timeoutId })
    //     .doGet({ get: "checkForms" });
    // }

    function submit() {
      handlers.onParseInput();
      lock();
      setUpdateFormButtonToSpinner();
      const form = connections.getCurrentForm();
      form.notes.push(Changes.makeNote());
      handlers.onSubmit(form.stringify());
    }

    function getCurrentStack() {
      return currentStack;
    }

    function setCurrentStack(newStack) {
      currentStack = newStack;
    }

    function getSavedForm() {
      return savedForm;
    }

    function setSavedForm(form) {
      savedForm = form;
      return exported;
    }

    function setHandlers(newHandlers) {
      Object.assign(handlers, newHandlers);
    }

    function setConnections(newConnections) {
      Object.assign(connections, newConnections);
    }

    function disable() {
      elements.omnibox.setAttribute("disabled", true);
      elements.newNoteButton.setAttribute("disabled", true);
      elements.manualButton.setAttribute("disabled", true);
      elements.omniboxButton.setAttribute("disabled", true);
      elements.updateButtonHint.textContent =
        "This is a closed form.  " + "You cannot edit it.";
      elements.copyButton.classList.remove("hidden");
      elements.duplicateButton.classList.remove("hidden");
      elements.advanceBookingButton.classList.add("hidden");
      elements.advanceBookingButton.setAttribute("disabled", true);
    }

    function enable() {
      elements.omnibox.removeAttribute("disabled");
      elements.newNoteButton.removeAttribute("disabled");
      elements.manualButton.removeAttribute("disabled");
      elements.omniboxButton.removeAttribute("disabled");
      elements.updateButtonHint.textContent = "";
      elements.copyButton.classList.add("hidden");
      elements.duplicateButton.classList.add("hidden");
      refreshUpdateButton();
    }

    function loseData() {
      Changes.clear();
      elements.updateButtonHint.textContent = "";
      elements.updateFormButton.disabled = true;
      elements.undoButton.disabled = true;
    }

    function getNext() {
      const form = currentStack.getNext();
      if (!form) {
        // we're already at the end
        elements.omnibox.focus();
        return;
      }
      if (!Changes.isSaved()) {
        currentStack.getPrevious(); // fix currentIndex
        // handlers.onUnsavedForm("nextForm");
        return loseDataWarning(() => {
          Changes.loseData();
          displayForm(currentStack.getNext());
        });
      }
      displayForm(form);
    }

    function getPrevious() {
      const form = currentStack.getPrevious();
      if (!form) {
        // we're already at the beginning
        elements.omnibox.focus();
        return;
      }
      if (!Changes.isSaved()) {
        currentStack.getNext(); // fix currentIndex
        // handlers.onUnsavedForm("previousForm");
        return loseDataWarning(() => {
          Changes.loseData();
          displayForm(currentStack.getPrevious());
        });
      }
      displayForm(form);
    }

    /** for form validation and attach beforeunload listener for unsaved changes */
    function handleChange(change) {
      if (
        (change.target.classList &&
          change.target.classList.contains("selectQuantity")) ||
        change.target == elements.omnibox
      ) {
        return;
      }

      switch (change.target.name) {
        case "location":
          handleChangeLocation(change);
          if (change.target.value === "Other") {
            return;
          }
          break;
        case "startDate":
        case "startHour":
        case "startMinute":
        case "startAMPM":
        case "endDate":
        case "endHour":
        case "endMinute":
        case "endAMPM":
          handleChangeTime(change);
          break;
        case "advanceBooking":
        case "notes":
          Changes.add(change);
          break;
        case "items":
        case "students":
          toast(change.target.value + " OK");
          Changes.add(change);
          break;
        case "manual": // SPECIAL CASE
          Changes.add(change);
          return; // no change to buttons or "saved" state for manual entries
      }

      Changes.saved = false;
      elements.undoButton.removeAttribute("disabled");
      const form = connections.getCurrentForm();
      if (form.isBlank()) {
        elements.updateFormButton.textContent = updateButtonText.enabled.CREATE;
        elements.advanceBookingButton.classList.remove("hidden");
      } else {
        elements.updateFormButton.textContent = updateButtonText.enabled.UPDATE;
        elements.advanceBookingButton.classList.add("hidden");
      }
      elements.updateFormButton.classList.add("create");

      // clear the old autosave, if it exists
      if (autosaveID !== null) {
        window.clearTimeout(autosaveID);
        autosaveID = null;
      }
      if (form.isReadyToPost()) {
        // automatically try to save in 60 seconds
        autosaveID = window.setTimeout(() => {
          // recheck form is still valid
          if (
            !connections.getCurrentForm().isReadyToPost() ||
            document.querySelector("div.overlay") // blocking modal is showing
          ) {
            return;
          }
          submit();
        }, 60000);
        // are we ready to close?
        const noShow = form.isNoShow();
        if (form.isReadyToClose() || noShow) {
          elements.updateFormButton.textContent =
            updateButtonText.enabled.CLOSE;
        } // Enable update button
        elements.advanceBookingButton.removeAttribute("disabled");
        elements.updateFormButton.removeAttribute("disabled");
        elements.updateButtonHint.textContent = noShow
          ? "This session is past due. Updating will mark the " +
            'students as "no show" and close the form.'
          : "your changes are not saved yet";
      } else {
        // Disable update button
        elements.advanceBookingButton.setAttribute("disabled", true);
        elements.updateFormButton.setAttribute("disabled", true);
        elements.updateButtonHint.textContent =
          "please enter start time, end time, location, " +
          "and at least one student";
      }
      elements.omnibox.focus();
    }

    function handleChangeLocation(change) {
      if (change.target.value === "none") {
        change.target.value = connections.getCurrentForm().location || "none";
        return;
      }
      if (change.target.value === "Other") {
        const input = HTML.createElement("input", { type: "text" });
        HTML.modal({
          children: [
            HTML.heading1("Location: Other"),
            HTML.paragraph(
              "Location must be on the 5th or 6th floor of 370 Jay Street."
            ),
            input,
          ],
          okText: "Set location",
          onOk: () =>
            handleChange({
              target: {
                name: "location",
                value: input.value || "none",
              },
            }),
          onClose: () =>
            handleChange({ target: { name: "location", value: "none" } }),
        });
        input.focus();
        return;
      }
      // update form
      connections.getCurrentForm().location = change.target.value;
      // update location select element
      const other = elements.locationOtherOption;
      if (Config.locations.has(change.target.value)) {
        other.textContent = other.value = "Other";
      } else {
        elements.locationSelect.value = other.textContent = other.value =
          change.target.value;
      }
      Changes.add(change);
    }

    function handleChangeTime(change) {
      touched.add(change.target);
      let t = parseDateAndTimeInputs();
      const els = elements.form;
      const startEls = [
        els.startDate,
        els.startHour,
        els.startMinute,
        els.startAMPM,
      ];
      const endEls = [els.endDate, els.endHour, els.endMinute, els.endAMPM];
      // CHECK #0: Are t.start and t.end valid?
      if (window.isNaN(t.startTime.getTime())) {
        startEls.forEach((el) => el.classList.add("error"));
        window.alert("please enter a valid start time.");
        return;
      } else if (window.isNaN(t.endTime.getTime())) {
        endEls.forEach((el) => el.classList.add("error"));
        window.alert("please enter a valid end time.");
        return;
      }
      // CHECK #1: If start is after end, if end is untouched, add 1 hour to end
      const userTouchedEnd = endEls.some((el) => touched.has(el));
      if (t.endTime.getTime() <= t.startTime.getTime()) {
        if (!userTouchedEnd) {
          const newEnd = new Date(t.startTime);
          newEnd.setHours(t.startTime.getHours() + 1);
          dateToInput(newEnd, els.endDate);
          t = parseDateAndTimeInputs();
        }
      }
      // CHECK #2: If start is still after end, display error to user
      if (t.endTime.getTime() <= t.startTime.getTime()) {
        endEls.forEach((el) => {
          el.classList.add("error");
        });
        window.alert("Start time is after end time.");
        return;
      } else {
        // In case there was an error before, reset the classLists
        startEls.forEach((el) => {
          el.classList.remove("error");
        });
        endEls.forEach((el) => {
          el.classList.remove("error");
        });
      }
      const form = connections.getCurrentForm();
      const startTime = DateUtils.getFormattedDate(t.startTime);
      els.startTime.value = form.startTime = startTime;
      const endTime = DateUtils.getFormattedDate(t.endTime);
      els.endTime.value = form.endTime = endTime;
      const type = change.target.name.slice(0, 1),
        newChange = { target: {} };
      if (type === "s") {
        newChange.target.name = "startTime";
        newChange.target.value = els.startTime.value;
      } else if (type === "e") {
        newChange.target.name = "endTime";
        newChange.target.value = els.endTime.value;
      }
      Changes.add(newChange);
    }

    function handleClickItem(click) {
      if (currentStack !== connections.getStack()) {
        return;
      }
      const data = click.target.parentNode.dataset;
      if (click.metaKey) {
        handlers.onItemMetaClick(data.id || data.barcode);
        return;
      }
      const itemRow = click.target.classList.contains("itemnotes")
        ? click.target.parentNode.previousSibling
        : click.target.parentNode;
      const form = connections.getCurrentForm();
      const key = itemRow.dataset.id === "" ? "barcode" : "id";
      const item =
        itemRow.dataset.id === ""
          ? form.items.getByBarcode(itemRow.dataset.barcode)
          : form.items.getById(itemRow.dataset.id);
      if (!item) {
        window.alert("cannot take note for " + itemRow.dataset[key]);
      }
      const radio = HTML.radio("itemOptions");
      const input = HTML.createElement("textarea");
      HTML.modal({
        children: [
          HTML.heading1("Add notes to item"),
          HTML.table(
            HTML.row(
              HTML.cell("Item cannot be found"),
              HTML.cell({ child: radio("missing") })
            ),
            HTML.row(
              HTML.cell("Other (please specifiy below"),
              HTML.cell({ child: radio("other") })
            )
          ),
          input,
        ],
        okText: "Add note",
        onOk: ({ modal }) => {
          const choice = HTML.getRadioValue(modal);
          let value = "";
          if (choice === "missing") {
            item.missing = true;
            value = `${item.description} marked as missing`;
          } else if (choice === "other") {
            item.notes = [item.notes, input.value].filter((s) => s).join(", ");
          }
          FormPage.updateItems({
            target: {
              name: "items",
              value,
            },
          });
        },
      });
      input.focus();
    }

    function handleClickStaticTable(click) {
      if (currentStack !== connections.getStack()) {
        return;
      }
      if (click.target.tagName != "TD") {
        return;
      }
      if (click.target.classList.contains("editable")) {
        if (!elements.omnibox.disabled) {
          const inputCell = HTML.getNextSibling(click.target);
          const input = HTML.getFirstChild(inputCell);
          switch (input.name) {
            case "location":
              resetLocation(); // select loses custom "Other"
              input.value = click.target.textContent;
              if (input.value == "") {
                // form is using custom "Other"
                input.value = "none"; // this will discard custom value
              }
              break;
            case "startDate": // fallthrough
            case "endDate":
              setTimeInputs();
              break;
          }
          click.target.classList.add("hidden");
          inputCell.classList.remove("hidden");
        }
      }
    }

    function setTimeInputs(...names) {
      ((names.length && names) || ["start", "end"]).forEach((name) => {
        const input = document.querySelector(`input[name="${name}Date"]`);
        const date = DateUtils.parseFormattedDate(
          elements.form[`${name}Time`].value
        );
        dateToInput(date, input);
      });
    }
    function dateToInput(date, input) {
      const hour = HTML.getNextSibling(input);
      const minute = HTML.getNextSibling(hour);
      const ampm = HTML.getNextSibling(minute);
      input.value = DateUtils.formatDashed(date);
      minute.value = DateUtils.roundMinutes(date.getMinutes());
      hour.value = DateUtils.parseHours(date.getHours());
      ampm.value = DateUtils.parseAMPM(date.getHours());
    }

    function handleClickStudent(click) {
      if (currentStack !== connections.getStack()) {
        return;
      }
      const netId = click.target.parentNode.dataset.netid;
      if (click.metaKey) {
        handlers.onStudentMetaClick(netId);
        return;
      }
      const students = connections.getCurrentForm().students;
      const student = students.find((s) => s.netId == netId);
      if (!student) {
        return window.alert("could not find student with NetID " + netId);
      }
      handleStudentNote(student);
    }

    function handleStudentNote(student) {
      const radio = HTML.radio("studentOptions");
      const input = HTML.createElement("textarea");
      HTML.modal({
        children: [
          HTML.heading1("Add notes to student"),
          HTML.table(
            HTML.row(
              HTML.cell("Student never showed up."),
              HTML.cell({ child: radio("no show") })
            ),
            HTML.row(
              HTML.cell("Student left without checking out."),
              HTML.cell({ child: radio("left") })
            ),
            HTML.row(
              HTML.cell("Other (please specify below)"),
              HTML.cell({ child: radio("other", true) })
            )
          ),
          input,
        ],
        okText: "Submit",
        onOk: ({ modal }) => {
          const choice = HTML.getRadioValue(modal);
          const textValue = input.value;

          if (choice === "left") {
            student.left = true;
            updateStudents({
              target: {
                name: "students",
                value: `${student.name} left without checking out`,
              },
            });
          } else if (choice === "no show") {
            handleChange({
              target: {
                name: "students",
                value: `${student.name} did not show up`,
              },
            });
          } else if (choice === "other") {
            saveNote(`${student.name}: ${textValue}`);
          }
        },
      });
      input.focus();
    }

    function hide() {
      touched = new Set();
      elements.container.classList.add("hidden");
      if (timeoutId !== null) {
        window.clearTimeout(timeoutId);
        timeoutId = null;
      }
      if (autosaveID !== null) {
        window.clearTimeout(autosaveID);
        autosaveID = null;
      }
      unlock();
    }

    function isLocked() {
      return locked;
    }

    function isSaved() {
      return Changes.isSaved();
    }

    /**
     * isShowing should verify if the user is currently on the single form view
     * @returns {bool}
     */
    function isShowing() {
      return !elements.container.classList.contains("hidden");
    }

    function lock() {
      locked = true;
    }

    function lockButtons() {
      elements.undoButton.setAttribute("disabled", true);
      elements.updateButtonHint.textContent = "";
      elements.updateFormButton.setAttribute("disabled", true);
    }

    function makeAdvanceBooking() {
      connections.getCurrentForm().makeAdvanceBooking();
      handleChange({
        target: { name: "advanceBooking", value: "Make advance booking" },
      });
    }

    function parseDateAndTimeInputs() {
      let startTime = new Date(elements.form.startDate.value + "T00:00:00"),
        endTime = new Date(elements.form.endDate.value + "T00:00:00"),
        startHour = +elements.form.startHour.value,
        endHour = +elements.form.endHour.value,
        startMinute = +elements.form.startMinute.value,
        endMinute = +elements.form.endMinute.value;
      const ampmConverter = (ampm, hour) => {
        if (ampm == "PM" && hour != 12) {
          hour += 12;
        } else if (ampm == "AM" && hour == 12) {
          // i.e. 12 AM
          hour = 0;
        }
        return hour;
      };
      startHour = ampmConverter(elements.form.startAMPM.value, startHour);
      endHour = ampmConverter(elements.form.endAMPM.value, endHour);
      startTime.setHours(startHour);
      startTime.setMinutes(startMinute);
      endTime.setHours(endHour);
      endTime.setMinutes(endMinute);

      return { startTime, endTime };
    }

    function refreshUpdateButton() {
      const currentForm = connections.getCurrentForm();
      elements.updateFormButton.setAttribute("disabled", true);
      if (currentForm && currentForm.isBlank()) {
        elements.updateFormButton.textContent = updateButtonText.enabled.CREATE;
        elements.updateFormButton.classList.add("create");
        elements.advanceBookingButton.classList.remove("hidden");
        elements.advanceBookingButton.setAttribute("disabled", true);
      } else {
        elements.updateFormButton.textContent = updateButtonText.disabled;
        elements.updateFormButton.classList.remove("create");
        elements.advanceBookingButton.classList.add("hidden");
      }
    }

    function resetLocation() {
      elements.locationSelect.value = "none";
      elements.locationOtherOption.value = elements.locationOtherOption.textContent =
        "Other";
    }

    function saveNote(body) {
      if (body.length < 1) {
        return;
      }
      const form = connections.getCurrentForm();
      const author = usernameDisplay.textContent;
      form.notes.push({
        timestamp: Date.now(),
        author,
        body,
      });
      handleChange({
        target: {
          name: "notes",
          value: body.length > 10 ? body.slice(0, 10) + "..." : body,
        },
      });
      elements.noteSection.appendChild(
        HTML.createElement("p", {
          textContent: `"Note: [${author}] ${body}`,
        })
      );
      if (elements.noteSection.classList.contains("hidden")) {
        elements.noteSection.classList.remove("hidden");
      }
    }
    function setTimeout() {
      // do not set this when viewing the archive stack
      // if (currentStack === OpenFormsPage.getStack()) {
      //   timeoutId = window.setTimeout(checkForms, 60000);
      // }
    }
    function show() {
      if (timeoutId === null) {
        setTimeout();
      }
      refreshUpdateButton();
      elements.deleteFormButton.innerHTML = "Delete this form";
      elements.container.classList.remove("hidden");
      if (!document.querySelector("div.overlay")) {
        // no blocking modal detected
        elements.omnibox.focus();
      }
      if (
        currentStack === connections.getStack() &&
        currentStack.getCurrentForm().isNoShow()
      ) {
        HTML.modal({
          child: HTML.paragraph(
            'The start time has passed and no one has checked in.  Do you want to close this form as a "no show?"'
          ),
          closeText: "Cancel",
          onOk: () =>
            handleChange({
              target: { name: "students", value: "no show" },
            }),
        });
      }
    }
    function unlock() {
      locked = false;
    }

    function loseDataWarning(onOk) {
      HTML.modal({
        children: [
          HTML.heading1("Warning, your changes are not saved"),
          HTML.paragraph("Are you sure?"),
        ],
        closeText: "Cancel",
        okText: "Lose changes",
        onOk,
      });
    }

    /**
     * @param {Form} form
     * @param {bool} archived - is this a closed form?
     * @return void
     */
    function displayForm(form) {
      resetLocation();
      for (const key in form) {
        switch (key) {
          case "items": {
            const items = form[key];
            HTML.empty(elements.itemList);
            if (items.getLength() > 0) {
              items.slice().reverse().forEach(makeItemRow);
            }
            break;
          }
          case "notes": {
            HTML.empty(elements.noteSection);
            const notes = form[key];
            if (notes.length == 0) {
              elements.form.notes.value = JSON.stringify([]);
              elements.noteSection.classList.add("hidden");
            } else {
              for (const note of notes) {
                if (!Utility.tryJsonParse(note.body)) {
                  elements.noteSection.appendChild(
                    HTML.createElement("p", {
                      textContent: `Note: [${note.author}] ${note.body}`,
                    })
                  );
                }
              }
              if (elements.noteSection.firstChild)
                elements.noteSection.classList.remove("hidden");
              else elements.noteSection.classList.add("hidden");
              elements.form.notes.value = JSON.stringify(notes);
            }
            break;
          }
          case "students": {
            const students = form[key];
            HTML.empty(elements.studentList);
            if (students.length > 0) {
              students.forEach(makeStudentRow);
            }
            break;
          }
          case "startTime": // fallthrough
          case "endTime": // fallthrough
          case "bookedStudents": // fallthrough
          case "contact": // fallthrough
          case "project": // fallthrough
          case "tape": // fallthrough
          case "overnight": // fallthrough
          case "location": {
            const td = document.querySelector("#" + key + "Display");
            if (form[key]) {
              // There's data to display
              HTML.attributes(td, {
                textContent: form[key],
                removeClass: "hidden",
              });
              td.parentNode.classList.remove("hidden");
              if (td.nextElementSibling) {
                td.nextElementSibling.classList.add("hidden");
              }
              if (["location", "startTime", "endTime"].includes(key)) {
                elements.form[key].value = form[key];
              }
              // if "Other" value, we need to put that value back into the select
              if (key === "location" && elements.form.location.value === "") {
                elements.locationOtherOption.value = elements.locationOtherOption.textContent =
                  form[key];
                elements.form[key].value = form[key];
              }
            } else {
              // There's not data, so maybe show an input for the user, and clear old data
              switch (key) {
                case "startTime":
                case "endTime": {
                  HTML.attributes(td, {
                    textContent: "",
                    class: "hidden",
                  });
                  elements.form[key].value = "";
                  td.nextElementSibling.classList.remove("hidden");
                  const today = new Date(),
                    dateInput = td.nextElementSibling.firstElementChild,
                    hourInput = dateInput.nextElementSibling,
                    minuteInput = hourInput.nextElementSibling,
                    ampmInput = minuteInput.nextElementSibling;
                  const hour = today.getHours();

                  minuteInput.value = DateUtils.roundMinutes(
                    today.getMinutes()
                  );
                  hourInput.value = DateUtils.parseHours(hour);
                  ampmInput.value = DateUtils.parseAMPM(hour);
                  dateInput.value = DateUtils.formatDashed(today);

                  break;
                }
                case "location":
                  HTML.attributes(td, {
                    class: "hidden",
                  });
                  td.nextElementSibling.classList.remove("hidden");
                  elements.locationSelect.value = "none";
                  break;
                default:
                  td.parentNode.classList.add("hidden");
              }
            }
            break;
          }
        }
      }
      // copy form
      savedForm = new Form(form);

      // cleanup
      Changes.clear();
      elements.omnibox.value = "";

      // indicate where this form is in the current stack, e.g. "1/6"
      const stack = currentStack;
      elements.currentFormstackDisplay.textContent =
        stack.getCurrentIndex() + 1 + "/" + stack.getLength();

      if (stack === connections.getStack()) {
        enable();
      } else {
        disable();
      }

      handlers.onDisplayForm();
    }

    function makeQuantityButtons(item, isArchive) {
      if (isArchive || item.checkIn || item.isSerialized()) {
        return document.createTextNode(item.getQuantity());
      }
      return HTML.createElement("span", {
        children: [
          HTML.createElement("button", {
            class: "quantity",
            onClick: () => handlers.onModalQuantityChange(item),
            textContent: item.getQuantity(),
          }),
          HTML.createElement("button", {
            class: "quantity",
            onClick: () => {
              const quantity = item.getQuantity();
              item.changeQuantity(1);
              updateItems({
                target: {
                  name: "items",
                  value: `${item.description} qty ${quantity} to ${
                    quantity + 1
                  }`,
                },
              });
            },
            textContent: "+",
          }),
        ],
      });
    }

    function makeItemRow(item) {
      const isArchive = currentStack !== connections.getStack();
      elements.itemList.appendChild(
        HTML.createElement("tr", {
          class: item.isSerialized ? "serialized" : "nonserialized",
          "data-id": item.id,
          "data-barcode": item.barcode,
          children: [
            HTML.cell({ child: makeQuantityButtons(item, isArchive) }),
            HTML.cell(item.description),
            HTML.cell(item.id),
            HTML.cell(
              item.checkOut
                ? item.checkOut
                : {
                    child: HTML.createElement("i", {
                      textContent: "Scan barcode to check out",
                    }),
                  }
            ),
            HTML.cell({ child: makeCheckInButton(item, isArchive) }),
          ],
        })
      );
      elements.itemList.appendChild(
        HTML.createElement("tr", {
          child: HTML.createElement("td", {
            colspan: 4,
            class: "itemnotes",
            textContent: "Notes: " + item.notes,
          }),
        })
      );
    }

    function makeCheckInButton(item, isArchive) {
      if (item.checkedOutAgain) {
        return document.createTextNode("");
      }
      if (item.missing) {
        return HTML.createElement("span", {
          class: "alert",
          textContent: "ITEM IS MISSING",
        });
      }
      if (isArchive || item.checkIn) {
        return document.createTextNode(item.checkIn);
      }
      if (!item.checkOut || !item.checkedOut) {
        return HTML.createElement("button", {
          class: "create",
          textContent: "Remove",
          onClick: () => {
            const form = connections.getCurrentForm();
            const item = form.items.removeByItem(item);
            updateItems({
              target: {
                name: "items",
                value: item.description + " removed",
              },
            });
          },
        });
      }
      if (!item.checkIn && item.isSerialized()) {
        return HTML.createElement("i", {
          textContent: "Scan barcode to return",
        });
      }
      const id = item.id || item.barcode;
      const checkInButton = HTML.createElement("button", {
        class: "action",
        textContent: "Check In",
        onClick: () => {
          const savedItem = FormPage.getSavedForm().items.find(
            (item) => (item.barcode || item.id) == id
          );
          if (!savedItem) {
            return window.alert(
              "This item was just checked-out. Update or revert the form to continue."
            );
          }
          const quantityToReturn =
            savedItem.getQuantity() > 1
              ? document.querySelector(`select[data-itemid="${id}"]`).value
              : undefined;
          handlers.onItemQuantityChange(savedItem, quantityToReturn, false);
        },
      });
      const quantity = item.getQuantity();
      if (quantity > 1) {
        return HTML.createElement("span", {
          "data-id": item.id,
          "data-barcode": item.barcode,
          children: [
            checkInButton,
            HTML.createElement("select", {
              class: "selectQuantity",
              "data-itemid": id,
              children: [
                HTML.createElement("option", {
                  value: "all",
                  textContent: "All",
                }),
                ...Array.from({ length: quantity - 1 }).map((_, i) =>
                  HTML.createElement("option", {
                    textContent: String(i + 1),
                  })
                ),
              ],
            }),
          ],
        });
      }
      return checkInButton;
    }

    function makeStudentRow(student) {
      const isArchive = currentStack !== connections.getStack();
      elements.studentList.appendChild(
        HTML.createElement("tr", {
          "data-netid": student.netId,
          children: [
            HTML.cell(student.name),
            HTML.cell(student.netId),
            HTML.createElement("td", {
              child: student.checkIn
                ? document.createTextNode(student.checkIn)
                : isArchive
                ? document.createTextNode("")
                : HTML.createElement("i", {
                    textContent: "Scan ID to sign in",
                  }),
            }),
            HTML.createElement("td", {
              child: student.left
                ? HTML.createElement("span", {
                    class: "alert",
                    textContent: "DID NOT CHECK OUT",
                  })
                : student.checkOut
                ? document.createTextNode(student.checkOut)
                : isArchive || !student.checkIn
                ? document.createTextNode("")
                : HTML.createElement("i", {
                    textContent: "Scan ID to sign out",
                  }),
            }),
          ],
        })
      );
    }

    function updateItems(change) {
      HTML.empty(elements.itemList);
      connections.getCurrentForm().items.reverse().forEach(makeItemRow);
      handleChange(change);
    }

    function updateStudents(change) {
      HTML.empty(elements.studentList);
      connections.getCurrentForm().students.forEach(makeStudentRow);
      handleChange(change);
    }

    function setUpdateFormButtonToSpinner() {
      HTML.empty(elements.updateFormButton);
      elements.updateFormButton.appendChild(HTML.spinner());
    }

    function setDeleteFormButtonToSpinner() {
      HTML.empty(elements.deleteFormButton);
      elements.deleteFormButton.appendChild(HTML.spinner());
    }
  })();
</script>
