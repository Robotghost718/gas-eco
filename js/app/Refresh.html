<script>
  /**
   * main server callback function
   * @see js/Init
   * this is attached to google.script.run.withSuccessHandler
   */
  /* global
    Form
    Stack
    app
    displayForm
    toast
    OpenFormsPage
    Omnibox
    FormPage
  */

  /**
   * app.refresh is the main callback attached to google.script.run.withSuccessHandler
   * @param {Object} response - from server, see gs/Main
   * @param {Object} [context] - from client, see google.script.run.withUserObject
   */
  app.refresh = function (response, context) {
    switch (response.target) {
      case "archive":
        try {
          app.pages.archive.stack.importForms(JSON.parse(response.formList));
        } catch (error) {
          app.run.doGet({
            get: "archive",
            datRangeJSON: app.pages.archive.getDateRangeAsJSON(),
            init: response.unlock,
          });
          break;
        }
        if (response.unlock) {
          app.elements.archiveButton.removeAttribute("disabled");
        } else {
          // remove spinner from query button
        }
        app.pages.archive.query();
        break;
      case "checkForms": {
        let newForms = JSON.parse(response.formList);
        if (!newForms[0]) {
          break;
        }
        newForms = new Stack(newForms);
        // determine current context, see FormPage.{show,hide}
        // for why timeoutId shows context
        if (
          //! Removing this "timeoutId" tracking. Rethink
          // context.timeoutId != app.pages.form.timeoutId ||
          FormPage.getCurrentStack() === app.pages.archive.filteredStack
        ) {
          break;
        }
        newForms.sortForms();
        const staleForm = FormPage.getCurrentStack().getCurrentForm();
        const newForm = newForms.getByID(staleForm.id);
        if (!newForm) {
          // must be a new form, nothing to do, abort
          break;
        }
        // are changes saved?
        if (app.changes.saved) {
          OpenFormsPage.setStack(newForms);
          app.doCommand("displayForm", newForm);
          // app.pages.form.setTimeout(); //! TODO rethink
        } else {
          if (newForm.hash != staleForm.hash) {
            // another instance has already updated this form; do not set timeout
            app.run.doPost({
              post: "rejected",
              form: staleForm.stringify(),
            });
            app.modal.handleError({
              target: "collision",
              storedForm: newForm,
              submittedForm: staleForm,
            });
          } else {
            // editing the current form; keep checking
            // app.pages.form.setTimeout(); //! TODO rethink
          }
        }
        break;
      }
      case "codabar":
        Omnibox.setRoster(JSON.parse(response.students));
        app.modal.hide();
        Omnibox.parse();
        break;
      case "collision":
        response.storedForm = JSON.parse(response.storedForm);
        response.submittedForm = JSON.parse(response.submittedForm);
        app.modal.handleError(response);
        //! TODO figure out another way to communicate this to FormPage
        // app.pages.form.elements.updateFormButton.textContent = "Update";
        break;
      case "items": {
        const inventory = Omnibox.getInventory();
        inventory.setItems(JSON.parse(response.items));
        if (inventory.getLength() < 1) {
          app.run.doGet({ get: "items", init: response.unlock });
          break;
        }
        if (response.unlock) {
          app.tryUnlock();
        }
        break;
      }
      case "invalid":
        app.modal.handleError(response);
        break;
      case "openForms": {
        const stack = OpenFormsPage.getStack();
        try {
          stack.importForms(JSON.parse(response.formList)).sortForms();
        } catch (error) {
          //! TODO this needs to be re-evaluated, can get stuck in an endless loop
          app.run.doGet({ get: "openForms", init: response.unlock });
          break;
        }
        FormPage.setCurrentStack(stack);
        //! TODO check that the "saved" prop is updated by something else, should be Changes.clear()
        // app.changes.saved = true;
        app.tryUnlock();
        break;
      }
      case "openFormsQuiet": {
        const stack = OpenFormsPage.getStack();
        if (context.timeoutId != OpenFormsPage.getRefreshId()) {
          break; // we are in an undefined state, abort
        }
        try {
          stack.importForms(JSON.parse(response.formList)).sortForms();
        } catch (error) {
          app.run.doGet({ get: "openFormsQuiet" });
          break;
        }
        break;
      }
      case "rejected":
        toast("The form you were editing was saved on the server.");
        break;
      case "signature":
        Omnibox.setRoster(JSON.parse(response.students));
        Omnibox.parse();
        break;
      case "startSignature":
        app.modal.signatureReady();
        break;
      case "students": {
        // doCommand 'signatureRecheck' refreshes here
        const roster = JSON.parse(response.students);
        Omnibox.setRoster(roster);
        if (roster.length < 1) {
          // TODO report bad roster
          app.run.doGet({ get: "students", init: response.unlock });
          break;
        }
        if (response.unlock) {
          app.tryUnlock();
        } else {
          Omnibox.parse();
        }
        break;
      }
      case "updateForm": {
        app.changes.saved = true;
        FormPage.lockButtons(); // disables "update" until next change
        FormPage.unlock(); // allows editing of form
        const updatedForm = new Form(JSON.parse(response.form));
        OpenFormsPage.getStack().replace(updatedForm).updateIndex(updatedForm);
        displayForm(updatedForm);
        break;
      }
      case "user":
        app.elements.usernameDisplay.textContent = response.user;
        break;
    }
  };
</script>
