<script>
  /* global
        app
        FormPage
        HTML
        DateUtils
        Utility
  */
  app.modal = {
    body: document.querySelector("div.modal p"),
    cancel: document.querySelector("button.modalcancel"),
    container: document.querySelector("div.modal"),
    heading: document.querySelector("div.modal h1"),
    input: document.querySelector("div.modal input"),
    link: document.querySelector("div.modal a"),
    ok: document.querySelector("button.modalok"),
    overlay: document.querySelector("div.overlay"),
    table: document.querySelector("div.modal table"),
    textarea: document.querySelector("div.modal textarea"),
    tmp: undefined, // stores strings (although not restricted to strings only, usually some key needed if user selects 'ok'

    strings: {
      ambiguous: {
        heading: "Check in or out?",
        body: "",
        ok: "",
      },
      changes: {
        heading: "Change Log",
        body: "",
        ok: "",
      },
      checkOutAgain: {
        heading: "Check out again?",
        body: " was already checked back in.",
        ok: "Check out again",
      },
      codabar: {
        heading: "ID not recognized",
        body:
          "If you scanned an ID, add it to the student's info by " +
          "submitting their NetID.  If you think you are seeing this " +
          'message in error, choose "close".',
        ok: "Submit",
      },
      collision: {
        heading: "Uh-oh, your form conflicts with another form",
        body:
          "Unfortunately, no automatic fix is available, but your form " +
          'has been saved.  To keep viewing your form, choose "Close".',
        ok: "Switch to the saved form",
      },
      error: {
        heading: "Error",
        body: "an error has occured",
        ok: "ok",
      },
      init: {
        // as defined in html/Modal.html
        heading: "Attention",
        body: "choose an option to exit",
        ok: "Ok",
      },
      itemQuantity: {
        heading: "Change Quantity",
        body: "Enter the new quantity:",
        ok: "Set Quantity",
      },
      itemNote: {
        heading: "Add notes to item",
        body: "",
        ok: "Submit",
      },
      location: {
        heading: "Location: Other",
        body: "Location must be on 5th or 6th floor of 370 Jay Street.",
        ok: "Set location",
      },
      manual: {
        heading: "Check out item without barcode",
        body:
          "Describe the item: (required, provide as much detail as possible)",
        ok: "Check Out",
      },
      query: {
        heading: "Search results",
        body: "Are you looking for one of these?",
        ok: "",
      },
      signatureReady: {
        heading: "Add signature",
        body:
          "Production area policy acknowledgment signature not found " +
          "for this person. All persons must read the policy and have " +
          "a signature on file. Please use the tablet to show the " +
          "person the policy and capture their signature. " +
          "Click the 'Signature Done/Recheck' when they are finished " +
          "using the tablet.",
        ok: "Signature Done/Recheck",
      },
      signatureWait: {
        heading: "Add signature",
        body: "Please wait...",
        ok: "",
      },
      undo: {
        heading: "Undo all changes",
        body: "Do you want to undo all changes since the last save?",
        ok: "Revert to saved form",
      },
      unsaved: {
        heading: "Warning, your changes are not saved",
        body: "Are you sure?",
        ok: "Lose Changes",
      },
    },

    // modal methods
    /**
     @param {[]} notes - saved notes, query changes for pending changes
     */
    displayChangeLog: function (notes) {
      HTML.empty(app.modal.table);
      app.modal.table.appendChild(
        HTML.createElement("tr", {
          children: ["Time", "User", "Field", "Value"].map((textContent) =>
            HTML.createElement("td", { textContent })
          ),
        })
      );
      // display saved changes
      for (const note of notes) {
        const changes = Utility.tryJsonParse(note.body);
        if (Array.isArray(changes)) {
          for (const change of changes) {
            app.modal.table.appendChild(
              HTML.createElement("tr", {
                children: [
                  DateUtils.getFormattedDate(new Date(change.timestamp)),
                  note.author,
                  Utility.uncamelCase(change.name),
                  change.value,
                ].map((textContent) =>
                  HTML.createElement("td", { textContent })
                ),
              })
            );
          }
        }
      }
      // display pending changes
      for (const change of app.changes.stack) {
        app.modal.table.appendChild(
          HTML.createElement("tr", {
            children: [
              DateUtils.getFormattedDate(new Date(change.timestamp)),
              app.elements.usernameDisplay.textContent, // note difference with saved changes!
              Utility.uncamelCase(change.name),
              change.value,
            ].map((textContent) => HTML.createElement("td", { textContent })),
          })
        );
      }

      app.modal.setStrings("changes");
      app.modal.show(app.modal.container, app.modal.table);
    },

    blurAllTextInputs: function () {
      Array.from(
        document.querySelectorAll('input[type="text"]')
      ).forEach((textInput) => textInput.blur());
    },

    getInput: function () {
      return app.modal.getValueAndClear(app.modal.input);
    },

    getLocation: function () {
      this.blurAllTextInputs();
      this.setStrings("location");
      this.input.setAttribute("placeholder", "enter location name");
      this.ok.setAttribute("value", "setLocationOther");
      this.show(this.container, this.ok, this.input);
      this.input.focus();
    },

    getNewCodabar: function (codabar /* string */) {
      app.modal.input.setAttribute("placeholder", "enter student's NetID");
      app.modal.blurAllTextInputs();
      app.modal.setStrings("codabar");
      app.modal.ok.setAttribute("value", "codabar");
      app.modal.show(app.modal.container, app.modal.ok, app.modal.input);
      app.modal.tmp = codabar;
    },

    getManual: function () {
      app.modal.setStrings("manual");
      app.modal.show(app.modal.container, app.modal.ok, app.modal.textarea);
      app.modal.ok.setAttribute("value", "saveManual");
      app.modal.textarea.focus();
    },
    getText: function () {
      return app.modal.getValueAndClear(app.modal.textarea);
    },

    // Interface for inputs, this is a private function, public calls getInput, getText
    getValueAndClear: function (inputElement) {
      let value = inputElement.value.trim();
      inputElement.value = "";
      return value;
    },

    handleAmbiguousItemAction: function (item) {
      this.tmp = item;
      this.setStrings("ambiguous");
      this.blurAllTextInputs();
      this.body.textContent = "Item: " + item.description;
      HTML.empty(this.table);
      this.table.appendChild(
        HTML.createElement("tr", {
          children: [
            HTML.createElement("td", {
              textContent: "Check the item back in?",
            }),
            HTML.createElement("td", {
              child: HTML.createElement("button", {
                value: "ambiguousCheckIn",
                textContent: "Check In",
              }),
            }),
          ],
        })
      );
      this.table.appendChild(
        HTML.createElement("tr", {
          children: [
            HTML.createElement("td", {
              textContent: "Check out more of these",
            }),
            HTML.createElement("td", {
              child: HTML.createElement("button", {
                value: "ambiguousCheckOut",
                textContent: "Check Out",
              }),
            }),
          ],
        })
      );
      this.show(this.container, this.table);
    },

    handleCheckOutAgain: function (item) {
      this.setStrings("checkOutAgain");
      this.body.textContent = item.description + this.body.textContent;
      this.ok.setAttribute("value", "checkOutAgain");
      this.tmp = item;
      this.show(this.container, this.ok);
    },

    /**
     * @param {obj} collision - has properties {obj} form, {obj} submittedForm
     */
    handleCollision: function (collision) {
      const m = app.modal;
      m.tmp = collision;
      m.setStrings("collision");
      m.ok.setAttribute("value", "collisionResolve");
      m.show(m.container, m.ok);
    },

    handleError: function (error) {
      app.errors.push(error);
      if (app.modal.heading.textContent != app.modal.strings.error.heading) {
        app.modal.showNextError();
      } // else the user is already seeing an error message
      // modal.hide will call showNextError when user is ready
    },

    /**
     * @param {Obj} info - an object with a 'message' string member
     */
    handleInfo: function (info) {
      app.errors.push(info);
      if (app.modal.heading.textContent != app.modal.strings.error.heading) {
        app.modal.showNextError();
      }
    },

    isShowing: function () {
      return !app.modal.container.classList.contains("hidden");
    },

    signatureReady: function () {
      let m = app.modal;
      m.setStrings("signatureReady");
      m.show(app.modal.container, app.modal.ok, app.modal.link);
      m.ok.setAttribute("value", "signatureRecheck");
    },

    signatureWait: function () {
      let m = app.modal;
      m.setStrings("signatureWait");
      m.show(app.modal.container);
    },

    showNextError: function () {
      let error = app.errors.shift();
      if (!error) {
        return;
      }
      app.modal.blurAllTextInputs();
      app.modal.setStrings("error");
      if (error.message) {
        app.modal.body.textContent = error.message;
        app.modal.show(app.modal.container);
      } else if (error.target == "collision") {
        app.modal.handleCollision(error);
      }
    },

    handleItemNote: function (item) {
      const m = app.modal,
        radio = HTML.makeRadio({
          name: "itemOptions",
          values: ["missing", "other"],
          checked: "other",
        });
      m.blurAllTextInputs();
      m.setStrings("itemNote");
      m.body.textContent = "Item: " + item.description;
      HTML.empty(m.table);
      if (!item.checkIn && !item.missing) {
        m.table.appendChild(
          HTML.createElement("tr", {
            children: [
              HTML.createElement("td", { textContent: "Item cannot be found" }),
              HTML.createElement("td", { child: radio["missing"] }),
            ],
          })
        );
      }
      m.table.appendChild(
        HTML.createElement("tr", {
          children: [
            HTML.createElement("td", {
              textContent: "Other (please specify below)",
            }),
            HTML.createElement("td", { child: radio["other"] }),
          ],
        })
      );
      app.modal.ok.setAttribute("value", "itemNote");
      app.modal.tmp = item;
      m.show(m.container, m.table, m.textarea, m.ok);
      m.textarea.focus();
    },

    handleKeydown: function (key) {
      if (key == "Enter") {
        this.hide();
        app.doCommand(this.ok.value);
      }
    },

    handleQuantityChange: function (item) {
      if (!item || item.isSerialized()) {
        return;
      }
      const m = app.modal;
      m.blurAllTextInputs();
      m.ok.setAttribute("value", "itemQuantity");
      app.modal.input.setAttribute("placeholder", "");
      m.tmp = item; // so we can asynchronously fetch if user selects OK
      m.setStrings("itemQuantity");
      m.body.textContent += ` (current quantity: ${item.getQuantity()})`;
      m.show(m.container, m.input, m.ok);
      m.input.focus();
    },

    handleQuery: function (queryResults) {
      this.setStrings("query");
      HTML.empty(this.table);
      for (const result of queryResults) {
        const display = result.value.name || result.value.description;
        const id =
          result.value.netId || result.value.id || result.value.barcode;
        if (id === "") continue;
        this.table.appendChild(
          HTML.createElement("tr", {
            "data-id": id,
            children: [display, id].map((textContent) =>
              HTML.createElement("td", { textContent })
            ),
          })
        );
      }
      this.show(this.container, this.table);
    },

    handleUndo: function () {
      app.modal.blurAllTextInputs();
      app.modal.setStrings("undo");
      app.modal.ok.setAttribute("value", "loseData_revert");
      app.modal.show(app.modal.container, app.modal.ok);
    },

    handleUnsavedForm: function (buttonValue) {
      app.modal.blurAllTextInputs();
      app.modal.setStrings("unsaved");
      app.modal.ok.setAttribute("value", "loseData_" + buttonValue);
      app.modal.show(app.modal.container, app.modal.ok);
    },

    hide: function () {
      // check if more errors need to be displayed
      if (app.errors.length > 0) {
        app.modal.showNextError();
        return;
      }
      // unlock form if cancelling from collision
      if (
        app.modal.heading.textContent == app.modal.strings.collision.heading
      ) {
        FormPage.unlock();
      }
      // hide whatever is hidden by default
      let elements = [
        app.modal.container,
        app.modal.ok,
        app.modal.input,
        app.modal.overlay,
        app.modal.table,
        app.modal.textarea,
        app.modal.link,
      ];
      for (let el of elements) {
        el.classList.add("hidden");
      }
      // use default heading so we can check heading for state
      app.modal.heading.textContent = app.modal.strings.init.heading;
      // focus omnibox if viewing single form
      if (FormPage.isShowing()) {
        document.querySelector("input.omnibox").focus();
      }
    },

    setStrings: function (key) {
      for (let element in app.modal.strings[key]) {
        app.modal[element].textContent = app.modal.strings[key][element];
      }
    },

    show: function (...elements) {
      app.modal.overlay.classList.remove("hidden");
      for (let el of elements) {
        el.classList.remove("hidden");
      }
    },
  };
</script>
