<script>
  /* global app Config DateUtils populateArchiveTable */
  app.pages.archive.filters = {
    isBooked: (form) => form.bookingId,
    isNotBooked: (form) => !form.bookingId,
    isTape: (form) => form.tape,
    byStudentName: (form) => {
      const inputs = app.pages.archive.elements.queryInputs;
      const studentQuery = inputs.students.value.toLowerCase().split(",");
      return studentQuery.every((nameLookingFor) => {
        nameLookingFor = nameLookingFor.toLowerCase().replace(/\s/g, "");
        return form.students.find((student) => {
          const name = student.name.toLowerCase().replace(/\s/g, "");
          return name.includes(nameLookingFor);
        });
      });
    },
    byMatchAllItemID: (form) => {
      const inputs = app.pages.archive.elements.queryInputs;
      const itemQuery = inputs.items.value.toUpperCase().split(",");
      return itemQuery.every(form.items.contains);
    },
    byMatchAnyItemID: (form) => {
      const inputs = app.pages.archive.elements.queryInputs;
      const itemQuery = inputs.items.value.toUpperCase().split(",");
      return itemQuery.some(form.items.contains);
    },
    byMissingItem: (form) => {
      return form.items.some((item) => item.missing);
    },
    byStudentLeft: (form) => {
      return form.students.some((student) => student.left);
    },
    byHasManual: (form) => {
      for (let note of form.notes) {
        try {
          let changes = JSON.parse(note.body);
          for (let change of changes) {
            if (change.name == "manual") {
              return true;
            }
          }
        } catch (e) {
          // not changes, ignore
        }
      }
      return false;
    },
    byHasNotes: (form) => {
      for (let note of form.notes) {
        try {
          // Unintuitive use of try/catch:
          JSON.parse(note.body); // (success == change log )
        } catch (e) {
          // (  error == global note)
          return true;
        }
      }
      return false;
    },
    byLateStudents: (form) => {
      const inGracePeriod = 15, // minutes
        outGracePeriod = 10,
        start = DateUtils.parseFormattedDate(form.startTime),
        end = DateUtils.parseFormattedDate(form.endTime);
      start.setMinutes(start.getMinutes() + inGracePeriod);
      end.setMinutes(end.getMinutes() + outGracePeriod);

      const checkedInOnTime = (student) =>
        !student.checkIn ||
        DateUtils.parseFormattedDate(student.checkIn).getTime() <=
          start.getTime();

      const studentIncompleteHTML = "DID NOT CHECK OUT";
      const checkedOutLate = (student) =>
        (student.checkIn &&
          (!student.checkOut || student.checkOut === studentIncompleteHTML)) ||
        (student.checkOut &&
          student.checkOut !== studentIncompleteHTML &&
          DateUtils.parseFormattedDate(student.checkOut).getTime() >
            end.getTime());

      return (
        !form.students.some(checkedInOnTime) ||
        form.students.some(checkedOutLate)
      );
    },
    byNoShow: (form) => form.students.every((s) => s.checkIn == null),
    byTimeRange: (form) => {
      const inputs = app.pages.archive.elements.queryInputs;
      const startRange = new Date(inputs.start.value + "T00:00:00"),
        endRange = new Date(inputs.end.value + "T23:59:59"),
        start = DateUtils.parseFormattedDate(form.startTime);
      if (
        start.getTime() <= startRange.getTime() ||
        start.getTime() >= endRange.getTime()
      ) {
        return false;
      }
      return true;
    },
    byLocation: (form) => {
      const inputs = app.pages.archive.elements.queryInputs;
      if (inputs.location.value != "Other") {
        if (form.location != inputs.location.value) {
          return false;
        }
      } else {
        if (Config.locations.has(form.location)) {
          return false;
        }
      }
      return true;
    },
  };

  app.pages.archive.query = function () {
    const archiveElements = app.pages.archive.elements.container,
      inputs = app.pages.archive.elements.queryInputs,
      appliedFilters = [];

    const dateInputs = archiveElements.querySelectorAll('input[type="date"]');
    if (!dateInputs[0].value) {
      // initialize date range inputs
      app.pages.archive.init();
    }

    appliedFilters.push(app.pages.archive.filters.byTimeRange); // always run

    if (inputs.location.value != "All") {
      appliedFilters.push(app.pages.archive.filters.byLocation);
    }

    if (inputs.students.value) {
      appliedFilters.push(app.pages.archive.filters.byStudentName);
    }

    if (inputs.items.value && inputs.matchItems.value == "all") {
      appliedFilters.push(app.pages.archive.filters.byMatchAllItemID);
    }

    if (inputs.items.value && inputs.matchItems.value == "any") {
      appliedFilters.push(app.pages.archive.filters.byMatchAnyItemID);
    }

    const checkboxes = archiveElements.querySelectorAll(
      'input[type="checkbox"]'
    );
    for (let i = 0; i < checkboxes.length; ++i) {
      if (checkboxes[i].checked) {
        appliedFilters.push(app.pages.archive.filters[checkboxes[i].name]);
      }
    }
    app.pages.archive.filteredStack.setForms(
      appliedFilters.reduce(
        (forms, func) => forms.filter(func),
        app.pages.archive.stack
      )
    );

    const length = app.pages.archive.filteredStack.getLength();
    app.pages.archive.elements.queryCount.textContent =
      length == 1 ? `${length} form` : `${length} forms`;
    app.pages.archive.filteredStack.sortForms();
    populateArchiveTable(app.pages.archive.filteredStack);
  };
</script>
