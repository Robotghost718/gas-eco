<script>
  /* global app Stack DateUtils populateArchiveTable */
  app.pages.archive = {
    elements: {
      container: document.querySelector("div.archiveContainer"),
      queryButton: document.querySelector('button[value="query"]'),
      queryCount: document.querySelector("span.querycount"),
      queryInputs: document.querySelector("form.query"),
      tableBody: document.querySelector("tbody.archive"),
      tableHead: document.querySelector("thead.archive"),
    },
    filteredStack: new Stack(),
    getDateRangeAsJSON: function () {
      const inputs = app.pages.archive.elements.queryInputs;
      return JSON.stringify({
        start: DateUtils.getFormattedDate(
          new Date(inputs.start.value + "T00:00:00")
        ),
        end: DateUtils.getFormattedDate(
          new Date(inputs.end.value + "T23:59:59")
        ),
      });
    },
    handleChange: function (change) {
      if (change.target.getAttribute("type") === "date") {
        // see if new date range exceeds old date range
        const range = app.pages.archive.range,
          inputs = app.pages.archive.elements.queryInputs;
        const start = new Date(inputs.start.value + "T00:00:00"),
          end = new Date(inputs.end.value + "T23:59:59"),
          oldStart = new Date(range.start + "T00:00:00"),
          oldEnd = new Date(range.end + "T23:59:59");
        // cancel change if start > end
        if (start.getTime() > end.getTime()) {
          inputs.start.value = range.start;
          inputs.end.value = range.end;
          app.modal.handleError(new Error("Range start can not be after end"));
          change.preventDefault();
          return;
        }
        if (
          start.getTime() < oldStart.getTime() ||
          end.getTime() > oldEnd.getTime()
        ) {
          app.pages.archive.update();
        } else {
          app.pages.archive.query();
        }
        // update range
        range.start = DateUtils.formatDashed(start);
        range.end = DateUtils.formatDashed(end);
      }
    },
    handleClickTable: function (click) {
      if (click.target.parentNode.classList.contains("hoveroff")) {
        return;
      }
      const id = click.target.parentNode.getAttribute("data-id");
      app.doCommand("displayForm", app.pages.archive.filteredStack.getByID(id));
    },
    handleClickTableHead: function (click) {
      app.pages.archive.stack.sortForms(click.target.dataset.sort);
      populateArchiveTable(app.pages.archive.stack);
    },
    init: function () {
      const inputs = app.pages.archive.elements.queryInputs,
        today = DateUtils.formatDashed(new Date());
      inputs.start.value = today;
      inputs.end.value = today;
      app.pages.archive.range.start = today;
      app.pages.archive.range.end = today;
    },
    /* query: see external file */
    range: {
      start: "", // 'yyyy-mm-dd'
      end: "", // 'yyyy-mm-dd'
    },
    isTodaySelected: function () {
      const today = new Date();
      today.setHours(0);
      today.setMinutes(0);
      today.setSeconds(0);
      today.setMilliseconds(0);
      const selectedEndTime = new Date(
        app.pages.archive.range.end + "T00:00:00"
      ).getTime();
      return selectedEndTime >= today.getTime();
    },
    show: function () {
      if (app.pages.archive.isTodaySelected()) {
        app.pages.archive.update();
      } else {
        app.pages.archive.query();
      }
      app.pages.form.currentStack = app.pages.archive.filteredStack;
      app.pages.archive.elements.container.classList.remove("hidden");
    },
    hide: function () {
      app.pages.archive.elements.container.classList.add("hidden");
    },
    refreshId: NaN,
    setInterval: function () {},
    sortBy: "startTime",
    sortDescending: false,
    stack: new Stack(),
    update: function () {
      app.spinner.inside(app.pages.archive.elements.queryButton);
      app.run.doGet({
        get: "archive",
        dateRangeJSON: app.pages.archive.getDateRangeAsJSON(),
      });
    },
  };
</script>
