<script>
/* global app utility populateArchiveTable */
app.pages.archive = {
  elements: {
    container:   document.querySelector('div.archiveContainer'),
    queryButton: document.querySelector('button[value="query"]'),
    queryCount:  document.querySelector('span.querycount'),
    queryInputs: document.querySelector('form.query'),
    tableBody:   document.querySelector('tbody.archive'),
    tableHead:   document.querySelector('thead.archive'),
  },
  handleChange: function(change) {
    if (change.target.getAttribute('type') == 'date') {
      // see if new date range exceeds old date range
      let range    = app.pages.archive.range,
          inputs   = app.pages.archive.elements.queryInputs,
          z = utility.date.zeropad;
      let start    = new Date(inputs.start.value + 'T00:00:00'),
          end      = new Date(inputs.end.value   + 'T23:59:59'),
          oldStart = new Date(range.start + 'T00:00:00'),
          oldEnd   = new Date(range.end   + 'T23:59:59');
      // cancel change if start > end
      if (start.getTime() > end.getTime()) {
        inputs.start.value = range.start;
        inputs.end.value = range.end;
        app.modal.handleError(new Error('Range start can not be after end'));
        change.preventDefault();
        return;
      }
      if (start.getTime() < oldStart.getTime() ||
            end.getTime() > oldEnd.getTime()) {
        app.pages.archive.update();
      } else {
        app.pages.archive.query();
      }
      // update range
      range.start = start.getFullYear() + '-'
        + z(start.getMonth() + 1) + '-' + z(start.getDate());
      range.end = end.getFullYear() + '-'
        + z(end.getMonth() + 1) + '-' + z(end.getDate());
    }
  },
  handleClickTable: function(click) {
    let findForm = function(form) {
      return form.id == click.target.parentNode.getAttribute('data-id');
    };
    let index = app.cache.archive.findIndex(findForm);
    if (index < 0) {
      return;
    }
    app.cache.currentIndex = index;
    app.doCommand('displayForm', app.cache.archive[index], true);
  },
  handleClickTableHead: function(click) {
    app.doCommand('sortForms', click.target.dataset.sort);
  },
  getDateRangeAsJSON: function() {
    let inputs = app.pages.archive.elements.queryInputs;
    let range = {};
    range.start = utility.date.getFormattedDate(
      new Date(inputs.start.value + 'T00:00:00')
    );
    range.end = utility.date.getFormattedDate(
      new Date(inputs.end.value   + 'T23:59:59')
    );
    return JSON.stringify(range);
  },
  init: function() {
    let inputs = app.pages.archive.elements.queryInputs,
        today = new Date();
    today = today.getFullYear() +
      '-' + utility.date.zeropad(today.getMonth() + 1) +
      '-' + utility.date.zeropad(today.getDate());
    inputs.start.value = today;
    inputs.end.value = today;
    app.pages.archive.range.start = today;
    app.pages.archive.range.end   = today;
  },
  query: function() {
    // use app.cache.archive, app.pages.archive.elements.queryInputs[input]
    const archiveElements = app.pages.archive.elements.container;
    let dateInputs = archiveElements.querySelectorAll('input[type="date"]'),
        inputs = app.pages.archive.elements.queryInputs;
    if (! dateInputs[0].value) { // initialize date range inputs
    const archiveElements = app.pages.archive.elements.container,
          dateInputs = archiveElements.querySelectorAll('input[type="date"]'),
          filters = [],
          inputs = app.pages.archive.elements.queryInputs;

    if (! dateInputs[0].value) { // initialize date range inputs
      app.pages.archive.init();
    }

    const startRange   = new Date(inputs.start.value + 'T00:00:00'),
          endRange     = new Date(inputs.end.value  + 'T23:59:59');
    let itemQuery    = inputs.items.value,
        studentQuery = inputs.students.value;

    if (studentQuery) {
      studentQuery = studentQuery.toLowerCase().split(',');
      studentQuery.forEach(utility.cleanStudent);
    }

    if (itemQuery) {
      itemQuery = itemQuery.toLowerCase().split(',');
    }

    // FILTERS
    const byTimeRange = form => {
      let start = utility.date.parseFormattedDate(form.startTime);
      if ((start.getTime() <= startRange.getTime()) ||
          (start.getTime() >= endRange.getTime())) {
        return false;
      }
      return true;
    };
    filters.push(byTimeRange); // always run

    const byLocation = form => {
      if (inputs.location.value != 'Other') {
        if (form.location != inputs.location.value) {
          return false;
        }
      } else {
        if (app.strings.locations.has(form.location)) {
          return false;
        }
      }
      return true;
    };
    if (inputs.location.value != "All") {
      filters.push(byLocation);
    }

    const isBooked = form => (form.bookingId);
    if (inputs.booked.checked) {
      filters.push(isBooked);
    }

    const isNotBooked = form => (! form.bookingId);
    if (inputs.nonbooked.checked) {
      filters.push(isNotBooked);
    }

    const isTape = form => (! form.tape);
    if (inputs.tape.checked) {
      filters.push(isTape);
    }

    const byStudentName = form => {
      let found = studentQuery.find(queryArg => {
        return form.students.find(student => {
          let name = student.name.toLowerCase().replace(/\s/g, '');
          return (name.search(queryArg) > -1);
        });
      });
      if (! found) {
        return false;
      }
      return true;
    };
    if (inputs.students.value) {
      filters.push(byStudentName);
    }

    const byMatchAllItemID = form => {
      let count = 0; // counts how many matches we have had
      itemQuery.forEach(queryArg => {
        let ran = false; // resets the ran flag
        let queryId = utility.cleanItem(queryArg);
        form.items.forEach(item => {
          const itemId = item.id.toLowerCase().replace(/-0+/, '-');
          const itemDesc = item.description.toLowerCase();
          if ((  itemId.search(queryId.trim()) > -1   ||
               itemDesc.search(queryArg.trim()) > -1) &&
               ! ran) { // if the id matches, increment count
            ++count;
            ran = true;
          }
        });
      });
      return count >= itemQuery.length;
    };
    if (inputs.items.value && inputs.matchAllItems.checked) {
      filters.push(byMatchAllItemID);
    }

    const byMatchAnyItemID = form => {
      let found = itemQuery.find(queryArg => {
        let queryId = utility.cleanItem(queryArg);
        return form.items.find(item => {
          const itemDesc = item.description.toLowerCase();
          const itemId = item.id.toLowerCase().replace(/-0+/, '-');
          if (itemId.search(queryId.trim()) > -1 ||
              itemDesc.search(queryArg.trim()) > -1) {
            return true;
          }
        });
      });
      if (! found) {
        return false;
      }
    };
    if (inputs.items.value && !inputs.matchAllItems.checked) {
      filters.push(byMatchAnyItemID);
    }

    const byMissingItems = form => {
      let found = false;
      checkMissingItem: for (let item of form.items) {
        if (item.missing){
          found = true;
          break checkMissingItem;
        }
      }
      if (! found) {
        return false;
      }
    };
    if (inputs.missingItem.checked) {
      filters.push(byMissingItems);
    }

    const byStudentLeft = form => {
      for (let student of form.students) {
        if (student.left) {
          return true;
        }
      }
      return false;
    };
    if (inputs.studentLeft.checked) {
      filters.push(byStudentLeft);
    }

    const byManualEntry = form => {
      for (let note of form.notes) {
        try {
          let changes = JSON.parse(note.body);
          for (let change of changes) {
            if (change.name == 'manual') {
              return true;
            }
          }
        } catch(e) {
          // not changes, ignore
        }
      }
      return false;
    };
    if (inputs.manual.checked) {
      filters.push(byManualEntry);
    }

    const byGlobalNotes = form => {
      for (let note of form.notes) {
        try {                    // Unintuitive use of try/catch:
          JSON.parse(note.body); // (success == change log )
        } catch(e) {             // (  error == global note)
          return true;
        }
      }
      return false;
    };
    if (inputs.notes.checked) {
      filters.push(byGlobalNotes);
    }

    const byLateStudents = form => {
      const gracePeriod = 15; // minutes
      let found = false,
          start = utility.date.parseFormattedDate(form.startTime),
          end   = utility.date.parseFormattedDate(form.endTime);
      start.setMinutes(start.getMinutes() + gracePeriod);

      const checkedInOnTime = function(student) {
        if (!student.checkIn) {
          return true; // i.e. no show != late
        }
        let checkIn = utility.date.parseFormattedDate(student.checkIn)
          .getTime();
        return (checkIn <= start.getTime());
      };

      const checkedOutLate = function(student) {
        if (student.checkIn && (! student.checkOut ||
            student.checkOut == app.strings.studentIncompleteHTML)) {
          return true; // checked-in student never checked-out
        }
        if (student.checkOut &&
            student.checkOut != app.strings.studentIncompleteHTML) {
          const checkOut = utility.date.parseFormattedDate(student.checkOut)
            .getTime();
          return (checkOut > end.getTime());
        } else { // must be a no show student
          return false;
        }
      };

      // late check-ins
      if (!form.students.every(checkedInOnTime)) {
        found = true;
      }
      // late check-outs
      if (form.students.some(checkedOutLate)) {
        found = true;
      }
      if (!found) {
        return false;
      }
    };
    if (inputs.late.checked) {
      filters.push(byLateStudents);
    }

    const byNoShow = form => {
      // check for some check-ins
      if (form.students.some(s => s.checkIn)) { // not a no show
        return false;
      }
    };
    if (inputs.noshow.checked) {
      filters.push(byNoShow);
    }
    // END FILTERS

    // APPLY FILTERS
    app.cache.archiveFiltered = filters.reduce(
      (forms, func) => forms.filter(func), app.cache.archive
    );

    if (app.cache.archiveFiltered.length == 1) {
      app.pages.archive.elements
        .queryCount.textContent = app.cache.archiveFiltered
          .length + ' form';
    } else {
      app.pages.archive
        .elements.queryCount.textContent = app.cache.archiveFiltered
          .length + ' forms';
    }
    utility.sortForms(app.cache.archiveFiltered);
    populateArchiveTable(app.cache.archiveFiltered);
  },
  range: {
    start: '', // 'yyyy-mm-dd'
    end: '',   // 'yyyy-mm-dd'
  },
  isTodaySelected: function() {
    const today = new Date();
    today.setHours(0);
    today.setMinutes(0);
    today.setSeconds(0);
    today.setMilliseconds(0);
    const selectedEndTime = new Date(
      app.pages.archive.range.end + 'T00:00:00'
    ).getTime();
    return selectedEndTime >= today.getTime();
  },
  show: function() {
    app.cache.currentFormstack = app.strings.formstack.archive;
    if (app.pages.archive.isTodaySelected()) {
      app.pages.archive.update();
    } else {
      app.pages.archive.query();
    }
    app.pages.archive.elements.container.classList.remove("hidden");
  },
  hide: function() {
    app.pages.archive.elements.container.classList.add("hidden");
  },
  refreshId: NaN,
  setInterval: function() {},
  update: function() {
    app.spinner.inside(app.pages.archive.elements.queryButton);
    app.run.doGet({
      get: 'archive',
      dateRangeJSON: app.pages.archive.getDateRangeAsJSON(),
    });
  },
};
</script>
