<script>
  /* global
    HTML
    Item
    Inventory
    DateUtils
    Utility
   */
  /* exported Omnibox */
  function Omnibox({ onSubmit }) {
    const { createElement } = HTML;
    let element = null;
    const inventory = new Inventory();
    let roster = [];

    return createElement("input", {
      type: "text",
    });

    function handleItem(item, quantityToReturn, ambiguous = true) {
      const form = connections.getCurrentForm();
      const itemOnForm = form.items.find((i) => {
        if (item.id && i.id == item.id) {
          return true;
        }
        if (item.barcode && i.barcode == item.barcode) {
          return true;
        }
        return false;
      });
      const change = {
        // fake change event
        target: {
          name: "items",
          value:
            item.id && !/^manual/i.test(item.id) ? item.id : item.description,
        },
      };

      if (!itemOnForm) {
        // new item
        item = new Item(item); // copy it
        item.checkOut = DateUtils.getFormattedDateTime(new Date());
        form.items.push(item);
        change.target.value += " check-out";
      } else if (quantityToReturn && quantityToReturn != "all") {
        itemOnForm.changeQuantity(-quantityToReturn);
        change.target.value = `returned ${quantityToReturn} ${change.target.value}`;
      } else {
        const savedItem = connections.getSavedForm().items.getByItem(item);
        if (itemOnForm.checkOut && itemOnForm.checkIn) {
          // checkout again?
          clear();
          if (!savedItem.checkIn) {
            window.alert(
              `${itemOnForm.description} ` +
                `was just checked-in.  Update or revert to check-out again.`
            );
            return;
          }
          return HTML.modal({
            children: [
              HTML.heading1("Check out again?"),
              HTML.paragraph(
                `${itemOnForm.description} was already checked back in.`
              ),
            ],
            okText: "Check out again",
            onOk: () => {
              itemOnForm.checkIn = "";
              itemOnForm.checkedOutAgain = true;
              handlers.onItemChange({
                target: {
                  name: "items",
                  value: `${itemOnForm.description} checked out again`,
                },
              });
            },
          });
        } else if (itemOnForm.checkOut) {
          // Its a check-in
          if (!savedItem || !savedItem.checkOut || itemOnForm.checkedOutAgain) {
            clear();
            if (!item.isSerialized()) {
              handlers.onQuantityChange(item);
              return;
            }
            return window.alert(
              `${item.description} was just checked-out. Update or revert the form to continue.`
            );
          }
          if (!item.isSerialized() && ambiguous) {
            clear();
            return getItemAction(itemOnForm);
          }
          itemOnForm.checkIn = DateUtils.getFormattedDateTime(new Date());
          // clears the missing property if it was set.
          itemOnForm.missing = false;
          change.target.value += " check-in";
        } else {
          // Its a check-out for reserved gear
          itemOnForm.checkOut = DateUtils.getFormattedDateTime(new Date());
          change.target.value += " check-out";
        }
      }
      clear();
      handlers.onItemChange(change);
    }

    /**
     * creates a dialog to determine if the user meant to check in an item
     * or check out more of the same item
     */
    function getItemAction(item) {
      HTML.modal({
        children: [
          HTML.heading1("Check in or out?"),
          HTML.table(
            HTML.row(
              HTML.cell("Check the item back in?"),
              HTML.cell({
                child: HTML.createElement("button", {
                  textContent: "Check In",
                  onClick: () => handleItem(item, "all", false),
                }),
              })
            ),
            HTML.row(
              HTML.cell("Check out more of these?"),
              HTML.cell({
                child: HTML.createElement("button", {
                  textContent: "Check Out",
                  onClick: makeQuantityChangeDialog(item),
                }),
              })
            )
          ),
        ],
      });
    }

    function makeQuantityChangeDialog(item) {
      const newQuantityInput = HTML.createElement("input", {
        class: "newQuantity",
      });
      return () =>
        HTML.modal({
          children: [
            HTML.heading1("Change quantity"),
            HTML.paragraph(
              `Enter the new quantity: (current quantity: ${item.getQuantity()})`
            ),
            newQuantityInput,
          ],
          okText: "Ok",
          onOk: makeQuantityHandler(item, newQuantityInput),
        });
    }

    function makeQuantityHandler(item, newQuantityInput) {
      return () => {
        const quantity = +newQuantityInput.value;
        const savedItem = connections
          .getSavedForm()
          .items.find(({ description }) => description === item.description);
        if (!item.checkedOutAgain && savedItem) {
          const savedQuantity = savedItem.getQuantity();
          if (quantity < savedQuantity) {
            window.alert(
              quantity +
                " is less than the previous quantity " +
                savedQuantity +
                ". You can only enter a larger amount " +
                "or check in this item."
            );
            return;
          }
        }
        try {
          item.setQuantity(quantity);
        } catch (error) {
          window.alert(error);
          return;
        }
        handlers.onItemChange({
          target: {
            name: "items",
            value: `${
              item.description
            } qty ${item.getQuantity()} to ${quantity}`,
          },
        });
      };
    }

    function handleKeydown(keydown) {
      if (keydown.key === "Escape") keydown.target.blur();
      if (keydown.key === "Enter") {
        keydown.preventDefault();
        parse();
        return;
      }
    }

    /** @param {Student} input */
    function handleStudent(student) {
      student = Object.assign({}, student);
      const form = connections.getCurrentForm();
      const students = form.students;
      const studentOnForm = students.find((s) => s.netId == student.netId);
      const change = {
        // fake change event
        target: {
          name: "students",
          value: student.name,
        },
      };

      if (!studentOnForm) {
        if (!student.signatureOnFile) {
          handlers.onNeedsSignature(student.netId);
          return;
        }
        student.checkIn = DateUtils.getFormattedDateTime(new Date());
        students.push(student);
        change.target.value += " check-in";
      } else {
        try {
          if (studentOnForm.checkIn && studentOnForm.checkOut) {
            throw new Error(studentOnForm.name + " is already checked out.");
          } else if (studentOnForm.checkIn) {
            const savedStudent = connections
              .getSavedForm()
              .students.find((s) => s.netId == student.netId);
            if (!savedStudent || !savedStudent.checkIn) {
              throw new Error(
                `${student.name} was just checked-in. Update the form before checking out.`
              );
            }
            if (form.hasItemsOut()) {
              throw new Error(
                "Cannot check out student. " +
                  "If this is the last student, all gear must be returned. " +
                  "Otherwise try updating the form."
              );
            }
            studentOnForm.checkOut = DateUtils.getFormattedDateTime(new Date());
            change.target.value += " check-out";
          } else {
            if (!student.signatureOnFile) {
              handlers.onNeedsSignature(student.netId);
              return;
            } else {
              studentOnForm.checkIn = DateUtils.getFormattedDateTime(
                new Date()
              );
              change.target.value += " check-in";
            }
          }
        } catch (error) {
          element.classList.add("error");
          window.alert(error.message);
          window.setTimeout(() => element.classList.remove("error"), 2000);
          return;
        }
      }
      clear();
      handlers.onStudentChange(change);
    }

    /**
     * parse examines the current value of the omnibox text input element
     *   and passes the value to the correct handler or shows the user an error.
     */
    function parse() {
      if (!element.value) return;

      // see the "Copy items to clipboard" button
      if (/^\s*\[\s*{\s*"/.test(element.value)) {
        // JSON array of objects: "[{}]"
        JSON.parse(element.value).forEach(handleItem);
        return;
      }

      const value = element.value.toLowerCase(); // case insenstive input
      // let parsed;
      // DETERMINE TYPE: ID card barcode, item barcode, item ID/SKU, student name
      const codabarRegex = /^[a-d][0-9]{5,}[a-d]$/; // "a123...789b" pattern
      if (codabarRegex.test(value)) {
        // Check student id
        const foundStudent = roster.find(
          (student) => student.id.toLowerCase() == value
        );
        if (foundStudent) {
          handleStudent(foundStudent);
          return;
        }
        // handlers.onNewCodabar(value);
        const input = HTML.createElement("input", {
          value: "codabar",
          placeholder: "enter student's NetID",
        });
        HTML.modal({
          children: [
            HTML.heading1("ID not recognized"),
            HTML.paragraph(
              "If you scanned an ID, add it to the student's info by " +
                "submitting their NetID.  If you think you are seeing this " +
                'message in error, choose "close".'
            ),
            input,
          ],
          okText: "Submit",
          onOk: () => {
            const netId = input.value;
            const student = getRoster().find(
              (student) => student.netId.toLowerCase() === netId
            );
            if (!student) {
              return window.alert(
                "Hmmm, NetID " +
                  netId +
                  " does not match a current student. " +
                  "Check that it was entered correctly, try refreshing the browser, " +
                  "or submit a trouble report."
              );
            }
            handlers.onNewCodabar({ netId, codabar: value });
          },
        });
        input.focus();
        return;
      }

      const idType = /^[a-z]+[0-9]+/.test(value) ? "netId" : "name"; // Check student name and id
      const foundStudent = roster.find(
        (student) => student[idType].toLowerCase() == value
      );
      if (foundStudent) {
        handlers.onLogManualEntry(element.value);
        handleStudent(foundStudent);
        return;
      }

      // two special cases: magic number for manual entry and generated "manual" IDs
      if (value === "10000") {
        clear();
        return manualEntry();
      }
      if (/^manual/.test(value))
        return handleItem(
          new Item(
            connections
              .getCurrentForm()
              .items.find(
                (item) => item.id.toLowerCase().replace(/-0+/, "-") == value
              )
          )
        );

      const foundItem =
        inventory.getById(value) || inventory.getByBarcode(value);
      if (foundItem) return handleItem(new Item(foundItem));

      clear();

      const queryResults = _query(
        value.replace(/'/g, ""),
        (obj) => {
          if (obj instanceof Item) {
            const keys = [];
            if (obj.description !== "") {
              keys.push(obj.description.trim().toLowerCase());
            }
            if (obj.id !== "") {
              keys.push(obj.id.trim().toLowerCase());
            }
            return keys;
          }
          // else it is a student
          return [obj.name.trim().toLowerCase().replace(/'/g, "")];
        },
        inventory.slice(),
        roster
      ).filter((result) => result.weight < 4);

      if (queryResults.length > 0) {
        return HTML.modal({
          children: [
            HTML.heading1("Search results"),
            HTML.paragraph("Are you looking for one of these?"),
            HTML.table(
              ...queryResults.reduce((rows, { value }) => {
                const id = value.netId || value.id || value.barcode;
                if (!id) return rows;
                return [
                  ...rows,
                  HTML.createElement("tr", {
                    children: [
                      HTML.cell(value.name || value.description),
                      HTML.cell(id),
                    ],
                    onClick: () => setInputAndParse(id),
                  }),
                ];
              }, [])
            ),
          ],
        });
      }
      HTML.modal({
        child: HTML.paragraph(
          `"${value}" not found.  You can type in item IDs like "NEU-1", or names like "John Smith".`
        ),
      });
    }

    function manualEntry() {
      const input = HTML.createElement("textarea");
      HTML.modal({
        children: [
          HTML.heading1("Check out item without barcode"),
          HTML.paragraph(
            "Describe the item: (required, provide as much detail as possible)"
          ),
          input,
        ],
        okText: "Check out",
        onOk: () => {
          const description = input.value;
          if (description === "") {
            return;
          }
          Utility.digestMessage(description).then((hash) => {
            handleItem({
              id: "MANUAL-" + Utility.hexString(hash).substring(0, 5),
              checkIn: null,
              checkOut: null,
              quantity: 1,
              serialized: false,
              barcode: null,
              description,
              checkedOut: false,
              notes: "",
              missing: false,
            });
          });
        },
      });
      input.focus();
    }

    /**
     * query searches through the supplied arrays inspected keys, as found with
     *   the supplied key making function, and returns a weighted result array.
     * The preliminary search filters inventory and roster for anything that
     *   seems to include the query expression.  As a simple misspelling aid,
     *   the expression is tokenized and matching starts from truncated strings
     *   and grows until a match might be found.
     * The second search does the opposite: the full tokens are examined and
     *   reduced if needed.  Each reduction (which could indicate a misspelling)
     *   causes an increase in the weight.
     *   The best results have a low weight, the worst results have a high weight.
     * @param {string} q - query expression
     * @param {function} keyMaker - ({}) => string[]
     * @param {{}[]} arrays - arrays to query
     * @returns {{value: {}, weight: number}[]}
     */
    function _query(q, keyMaker, ...arrays) {
      const expression = q.trim().toLowerCase();
      const sep = /[\s\W]+/;
      const terms = expression.split(sep);
      // reduce the large set of possibilities to a narrow set of possibilities
      const preliminary = function (obj) {
        const keys = keyMaker(obj);
        for (const term of terms) {
          if (term.length < 3) {
            continue;
          }
          for (let i = 3; i <= term.length; ++i) {
            for (const key of keys) {
              if (key.includes(term.slice(0, i))) {
                return true;
              }
            }
          }
        }
      };
      const results = arrays
        .reduce((reduced, arr) => reduced.concat(arr), [])
        .filter(preliminary);

      // examine the subset and score how good the result appears to be
      const score = { BEST: 0, GOOD: 1, BAD: 10 };
      const weigh = (value) => {
        const keys = keyMaker(value);
        let minWeight = score.BAD;
        for (
          let str = expression;
          str.length > 2;
          str = str.slice(0, str.length - 1)
        ) {
          for (const key of keys) {
            if (key.includes(str)) {
              if (key === str || key.startsWith(str)) {
                const weight = score.BEST + expression.length - str.length;
                minWeight = weight < minWeight ? weight : minWeight;
                str = "";
                break;
              }
            }
          }
        }
        // term by term matching: these results are averaged
        // we want results that match all of the user's input to get the best scores
        const termScores = [];
        for (let i = 0; i < terms.length; ++i) {
          for (
            let str = terms[i];
            str.length > 2;
            str = str.slice(0, str.length - 1)
          ) {
            for (const key of keys) {
              if (key.includes(str)) {
                termScores.push(score.GOOD + terms[i].length - str.length);
                str = "";
                break;
              }
            }
          }
          if (termScores.length === i) {
            // implies we didn't push a good score
            termScores.push(score.BAD);
          }
        }
        const average =
          termScores.reduce((sum, val) => sum + val) / termScores.length;
        minWeight = average < minWeight ? average : minWeight;
        return { value, weight: minWeight };
      };
      const weightedResults = results.map(weigh);
      weightedResults.sort((a, b) => a.weight - b.weight);
      return weightedResults;
    }
  }
</script>
